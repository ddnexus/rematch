# frozen_string_literal: true

require 'fileutils'
require 'yaml'
require_relative 'rematch/source'
require_relative 'rematch/store'

# Handles the key/value store for each test file
class Rematch
  VERSION = '5.0.0'
  CONFIG  = { ext: '.yaml' }  # rubocop:disable Style/MutableConstant

  @rebuild      = false
  @rebuilt      = []
  @skip_warning = false
  @cache        = {} # Cache per file path: { source: Source, store: Store }

  class << self
    attr_accessor :rebuild, :skip_warning, :cache

    def check_rebuild(path)
      return unless @rebuild && !@rebuilt.include?(path)

      FileUtils.rm_f(path)
      @rebuilt << path
      puts "Rebuilt #{path}"
    end

    # Utility used by the plugin to extract label from args (kept for compatibility)
    def extract_label(args) = ((args.last.is_a?(Hash) && args.last.key?(:label) && args.pop) || {})[:label]

    # Get source and store for the test file (cached because invoked for every test in the file)
    def environment(path)
      return cache[path] if cache[path]

      store_path = "#{path}#{CONFIG[:ext]}"
      check_rebuild(store_path)

      source      = Source.new(File.read(path))
      source_ids  = source.index.values.flatten.to_set
      store       = Store.new(store_path, source_ids)
      cache[path] = { source: source, store: store }
    end
  end

  def initialize(test)
    @path   = test.method(test.name).source_location.first
    @env    = self.class.environment(@path)
    @counts = Hash.new(0) # Track rematch counts per line
  end

  # Retrieves the stored value for the current assertion, updating the store if the key is new or moved.
  def rematch(value, overwrite: nil, label: nil)
    lineno = caller_locations.find { |l| l.path == @path }&.lineno
    ids    = @env[:source].index[lineno]
    raise "Rematch Error: No code detected at #{@path}:#{lineno}. Please check syntax." if ids.empty? # never happen

    count   = (@counts[lineno] += 1)
    id      = ids[(count - 1) % ids.size]
    new_key = %(L#{lineno}#{".#{count}" if count > 1}#{" [#{label}]" if label} #{id})
    store   = @env[:store]
    old_key = store.pull(id)
    if old_key && old_key != new_key  # Reconcile Move first to ensure clean state
      store[new_key] = store.delete(old_key)
      old_key        = new_key   # Normalize so we only check the verwrite logic below
    end
    case
    when !old_key
      warn "Rematch stored new value generated by: #{@path}:#{lineno}\n" unless overwrite || self.class.skip_warning
      store[new_key] = value
    when overwrite
      store[new_key] = value
    else
      store[new_key]
    end
  end

  def save = @env[:store].save
end
